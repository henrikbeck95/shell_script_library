#!/usr/bin/env bash

##############################
#Task list
##############################
#
#- [ ] Edit modules files
#   - [ ] Insert shebang header on all modules files for avoiding linter problems detection.
#   - [ ] Remove the individual shebang header from all individual modules. Use only the header.txt one.
#   - [ ] 
#- [ ] Minify shell script file.
#   - [x] Minify the final shell script version softly.
#   - [x] Minify the final shell script version hardly.
#   - [ ] Check if informed path is a valid shell script file.
#   - [ ] Define '$PATH_FILE_OUTPUT' file from arguments besides copying the same '$PATH_FILE_INPUT' name.
#   - [ ] Reuse file extension but set '.min' value before '.sh'. So, '.min.sh' file will be set.
#   - [ ] Split AWK into separated variables.
#   - [ ] DO NOT remove lines whose starts with '#@'
#   - [ ] Remove Commentaries from middle or end of line.
#   - [ ] Compress all the file content into only one line.
#   - [ ] 
#- [ ] Create the reverse engineer mode
#   - [ ] For library.
#   - [ ] For tester.
#- [ ] 
#   - [ ] 
#
##############################

##############################
#Declaring variables
##############################

#Use path /run/host/ #For Flatpak applications
PATH_SCRIPT="$(dirname "$(readlink -f "$0")")"
PATH_LIBRARY_MODULES_FILES_COMPILING="$PATH_SCRIPT/modules"
PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY="$PATH_SCRIPT/shell-script-library"
PATH_LIBRARY_MODULES_FILES_RESULT_TESTER="$PATH_SCRIPT/shell-script-library-tester"
PATH_LIBRARY_STORAGE_FILE_RESULT=""

#shellcheck source=/dev/null
#. "$PATH_SCRIPT/settings.conf" || echo -e "Settings file could not be found. Check it out before procedure!" && exit
. "$PATH_SCRIPT/settings.conf" || exit

#Check if user has root proviledges
case "$UID" in
0) PATH_LIBRARY_STORAGE_FILE_RESULT="$PATH_LIBRARY_STORAGE_FILE_SYSTEM" ;;
*) PATH_LIBRARY_STORAGE_FILE_RESULT="$PATH_LIBRARY_STORAGE_FILE_USER" ;;
esac

MESSAGE_HELP="
\t\t\t\t\t\t\t$SOFTWARE_MERGER_NAME
\t\t\t\t\t\t\t---------------------------
[Credits]
Author: $SOFTWARE_MERGER_AUTHOR
E-mail: $SOFTWARE_MERGER_EMAIL
License: $SOFTWARE_MERGER_LICENSE
Version: $SOFTWARE_MERGER_VERSION

[Description]
This is a dedicated merger tool for $SOFTWARE_LIBRARY_NAME project which can be used to pack all modules into one single file. This is the way the final $SOFTWARE_LIBRARY_NAME archieve is generated by default.

Furthermore this tool also generate the unit test file for debugging the $SOFTWARE_LIBRARY_NAME.

[Extra functions]
1. This tool can be used as a default installer of the $SOFTWARE_LIBRARY_NAME. By running this script file with root permition the generated $SOFTWARE_LIBRARY_NAME is going to be installed on $PATH_LIBRARY_STORAGE_FILE_SYSTEM path. Without root previledges it is going to be installed on $PATH_LIBRARY_STORAGE_FILE_USER path. In case the $SOFTWARE_LIBRARY_NAME is already installed, this tool makes the $SOFTWARE_LIBRARY_NAME update.

1. This tool can be used to uninstall the $SOFTWARE_LIBRARY_NAME.

1. This tool can be used to clear all the files modules content but still presenving the generated $SOFTWARE_LIBRARY_NAME file. The reason of this function has created was to solve the problem when this project must hardly rename functions from many modules at once. One real example was about when display_message_empty api was renamed to display_message_value_status_empty_simple. Many of bugs would be avoid if this tool had been existed. By the way it can be very useful in future source code refactory (this is in experimental mode).

[Merger rules]
Modules files names whose ends with _.sh character is considered as part of the unit test.
Modules files names whose starts with _ character is ignored by the merger.
Modules files names whose does not start with _ character and does not end w _.sh character is considered as part of the library.
Only .sh files are processed. Except for header.txt and header_.txt files.

[Parameters]
-h\t\t--help\t-?\t\tDisplay this message help
-e\t\t--edit\t\t\tEdit this script file with $EDITOR software.
    (Not implemented) -c-library\t--clear-library\t\tClear all the library modules files content from ${PATH_LIBRARY_MODULES_FILES_COMPILING}/.
    (Not implemented) -c-tester\t--clear-tester\t\tClear all the tester modules files content from ${PATH_LIBRARY_MODULES_FILES_COMPILING}/.
-d\t\t--download\t\tClone Shell Script Library repository to $REPOSITORY_CLONE_PATH or update if it is already cloned.
-i\t\t--install\t\tInstall the $SOFTWARE_LIBRARY_NAME by moving the compiled file to ${PATH_LIBRARY_STORAGE_FILE_RESULT}.
-m-library\t--merge-library\t\tCompile all the library modules files content into ${PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY}.
-m-library\t--merge-library\t\tCompile all the tester modules files content into ${PATH_LIBRARY_MODULES_FILES_RESULT_TESTER}.
-r-library\t--run-library\t\tRun/import $PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY file.
-r-tester\t--run-tester\t\tRun $PATH_LIBRARY_MODULES_FILES_RESULT_TESTER file.
-u\t\t--uninstall\t\tUninstall the $SOFTWARE_LIBRARY_NAME by removing the compiled file from ${PATH_LIBRARY_STORAGE_FILE_RESULT}.
-v\t\t--version\t\tDisplay $SOFTWARE_MERGER_NAME version

[Example]
    > $ $HOME/workspace/shell_script_library/src/merger.sh --merge-library --install
"

##############################
#Functions - tools (also available from modules)
##############################

string_replace_text() {
    local PATH_FILE="$1"
    local TEXT_OLD="$2"
    local TEXT_NEW="$3"

    #echo -e "PATH_FILE:\t\t$PATH_FILE"
    #echo -e "TEXT_OLD:\t\t$TEXT_OLD"
    #echo -e "TEXT_NEW:\t\t$TEXT_NEW"

    #Replace all the match values in a text file
    sed -i "s/$TEXT_OLD/$TEXT_NEW/g" "$PATH_FILE"
}

utils_check_if_file_exists() {
    local VALUE_PATH_FILE="$1"

    if [[ -f $VALUE_PATH_FILE ]]; then
        echo "true"
    else
        echo "false"
    fi
}

utils_check_if_folder_exists() {
    local VALUE_PATH_FOLDER="$1"

    if [[ -d "$VALUE_PATH_FOLDER" ]]; then
        echo "true"
    else
        echo "false"
    fi
}

utils_clear_file() {
    local PATH_FILE="$1"

    echo -e "Clearing terminal history"

    case $(utils_check_if_file_exists "$PATH_FILE") in
    "false")
        echo -e "File $PATH_FILE does not exists"
        ;;
    "true")
        cat /dev/null >"$PATH_FILE"
        ;;
    esac
}

##############################
#Functions - normal
##############################

#@annotation_must_be_fixed
#@annotation_must_be_improved
#@annotation_must_be_tested
#shell_script_library_minify_hard(){
#    local PATH_FILE_INPUT="$1"
#    local PATH_FILE_MINIFY_SOFT="${PATH_FILE_INPUT}.min.soft"
#    #local PATH_FILE_OUTPUT="${PATH_FILE_INPUT}.min.hard"
#    local PATH_FILE_OUTPUT="/tmp/lalala.min.hard"
#    local CODE_STATUS_EXIT
#
#    #PATH_FILE_MINIFY_SOFT= 
#    shell_script_library_minify_soft "$PATH_FILE_INPUT"
#}

#@annotation_must_be_improved
shell_script_library_minify_soft(){
    local PATH_FILE_INPUT="$1"
    local PATH_FILE_OUTPUT="${PATH_FILE_INPUT}.min"
    local CODE_STATUS_EXIT

    #Check if variable exists
    if [[ -z "$PATH_FILE_INPUT" ]]; then
        echo "FAILURE! Nullable argument value set to 'PATH_FILE_INPUT' variable."
        exit 1
    fi

    case $(utils_check_if_file_exists "$PATH_FILE_INPUT") in
    "false") 
        echo "FAILURE! '$PATH_FILE_INPUT' file does not exists"
        exit 1
        ;;
    "true") 
        #Removing all empty lines and removing all lines whose starts with spaces or commented signed with '#'
        ####Remove all empty lines
        ####Remove lines that begin with spaces and a comment sign #
        ####Remove all comment lines (meaning, lines that begin with a "#")
        awk '
            (/.*/ || /#!/) && (!/^#$/) &&
            (!/^#[[:blank:]]/) && (!/^#[a-z]/) && 
            (!/^#[A-Z]/) && (!/^##/) &&
            (!/^\t#/) && (!/^[[:space:]]*$/) &&
            ( /^#.*!/ || !/^[[:space:]]*#/)
        ' "${PATH_FILE_INPUT}" | sed 's_^[[:space:]]*__g' > "$PATH_FILE_OUTPUT" 2>/dev/null
        #' ${PATH_FILE_INPUT} > "$PATH_FILE_OUTPUT" 2>/dev/null #Comment out the above line and uncomment this line if your HEREDOCS are affected

        CODE_STATUS_EXIT=$?
        
        if [[ "$CODE_STATUS_EXIT" -eq 0 ]] && [[ -s "$PATH_FILE_OUTPUT" ]] ; then
            echo "SUCCESS! '$PATH_FILE_INPUT' file has been minified to '$PATH_FILE_OUTPUT' file."
            exit 0
        else
            echo "FAILURE! Unable to minify '$PATH_FILE_INPUT' to '$PATH_FILE_OUTPUT' file."
            exit 1
        fi
        ;;
    esac
}

shell_script_library_repository_clone(){
    case $(utils_check_if_folder_exists "$REPOSITORY_CLONE_PATH") in
    "false")
        echo -e "Cloning the $REPOSITORY_CLONE_URL to $REPOSITORY_CLONE_PATH..."
        git clone "$REPOSITORY_CLONE_URL" "$REPOSITORY_CLONE_PATH" && \
            echo -e "Shell Script Library is avaliable at $REPOSITORY_CLONE_PATH/ directory"
        ;;
    "true")
        echo -e "Updating Shell Script Library repository from $REPOSITORY_CLONE_PATH ..."

        cd "$REPOSITORY_CLONE_PATH"
        git pull
        cd -
        ;;
    esac
}

#@annotation_must_be_tested
shell_script_library_modules_action_clear_library() {
    local FILENAME_WITH_FULL_PATH="$1"
    local FILENAME_WITHOUT_FULL_PATH="${FILENAME_WITH_FULL_PATH##*/}"

    #Check if file name does not start with _ character
    if [[ ! "$FILENAME_WITHOUT_FULL_PATH" =~ ^_ ]]; then
        echo "Clearing the $FILENAME_WITH_FULL_PATH module file content..."
        utils_clear_file "$FILENAME_WITH_FULL_PATH"
    fi
}

#@annotation_must_be_tested
shell_script_library_modules_action_clear_tester() {
    local FILENAME_WITH_FULL_PATH="$1"
    local FILENAME_WITHOUT_FULL_PATH="${FILENAME_WITH_FULL_PATH##*/}"

    #Check if file name starts with _ character
    if [[ "$FILENAME_WITHOUT_FULL_PATH" =~ ^_ ]]; then
        echo "Clearing the $FILENAME_WITH_FULL_PATH module file content..."
        utils_clear_file "$FILENAME_WITH_FULL_PATH"
    fi
}

shell_script_library_modules_action_merge_library() {
    local FILENAME_WITH_FULL_PATH="$1"
    local FILENAME_WITHOUT_FULL_PATH="${FILENAME_WITH_FULL_PATH##*/}"

    local REGEX_EXPRESSION_A='^_.*.sh'
    local REGEX_EXPRESSION_B='.*_.sh'

    #Check if file name does not start with _ character and does not ends with _.sh value
    if [[ ! "$FILENAME_WITHOUT_FULL_PATH" =~ $REGEX_EXPRESSION_A ]] && [[ ! "$FILENAME_WITHOUT_FULL_PATH" =~ $REGEX_EXPRESSION_B ]]; then
        #echo "Compiling the $FILENAME_WITHOUT_FULL_PATH module file content into $PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY..."
        echo -e "\n" >>"$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY"
        cat "$FILENAME_WITH_FULL_PATH" >>"$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY"
    fi

    shell_script_library_set_values_to_credits_library
}

shell_script_library_modules_action_merge_tester() {
    local FILENAME_WITH_FULL_PATH="$1"
    local FILENAME_WITHOUT_FULL_PATH="${FILENAME_WITH_FULL_PATH##*/}"

    local REGEX_EXPRESSION='.*_.sh'

    #Check if file name starts with _ character
    if [[ "$FILENAME_WITHOUT_FULL_PATH" =~ $REGEX_EXPRESSION ]]; then
        #echo "Compiling the $FILENAME_WITHOUT_FULL_PATH module file content into $PATH_LIBRARY_MODULES_FILES_RESULT_TESTER..."

        echo -e "\n" >>"$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"
        cat "$FILENAME_WITH_FULL_PATH" >>"$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"
    fi

    shell_script_library_set_values_to_credits_tester
}

#This function is going to be used for splitting the generated file into theirs respectively modules (reverse engineer method)
#shell_script_library_modules_action_reverse_library(){}

#This function is going to be used for splitting the generated file into theirs respectively modules (reverse engineer method)
#shell_script_library_modules_action_reverse_tester(){}

shell_script_library_run_library() {
    case $(utils_check_if_file_exists "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY") in
    "false") echo "Error! $PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY file does not exists" ;;
    "true")
        chmod +x "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY"
        "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY"
        ;;
    esac
}

shell_script_library_run_tester() {
    case $(utils_check_if_file_exists "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER") in
    "false") echo "Error! $PATH_LIBRARY_MODULES_FILES_RESULT_TESTER file does not exists" ;;
    "true")
        chmod +x "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"
        "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"
        ;;
    esac
}

shell_script_library_set_values_to_credits_library() {
    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY" \
        "SOFTWARE_LIBRARY_AUTHOR" \
        "$SOFTWARE_LIBRARY_AUTHOR"

    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY" \
        "SOFTWARE_LIBRARY_EMAIL" \
        "$SOFTWARE_LIBRARY_EMAIL"

    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY" \
        "SOFTWARE_LIBRARY_LICENSE" \
        "$SOFTWARE_LIBRARY_LICENSE"

    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY" \
        "SOFTWARE_LIBRARY_VERSION" \
        "$SOFTWARE_LIBRARY_VERSION"

    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY" \
        "SOFTWARE_SHEBANG_LIBRARY" \
        "$SOFTWARE_SHEBANG_LIBRARY"
}

shell_script_library_set_values_to_credits_tester() {
    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER" \
        "SOFTWARE_TESTER_AUTHOR" \
        "$SOFTWARE_TESTER_AUTHOR"

    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER" \
        "SOFTWARE_TESTER_EMAIL" \
        "$SOFTWARE_TESTER_EMAIL"

    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER" \
        "SOFTWARE_TESTER_LICENSE" \
        "$SOFTWARE_TESTER_LICENSE"

    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER" \
        "SOFTWARE_TESTER_VERSION" \
        "$SOFTWARE_TESTER_VERSION"

    string_replace_text \
        "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER" \
        "SOFTWARE_SHEBANG_TESTER" \
        "$SOFTWARE_SHEBANG_TESTER"
}

##############################
#Functions - calling
##############################

shell_script_library_install() {
    case $(utils_check_if_file_exists "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY") in
    "false") : ;;
    "true") echo -e "Reinstalling the ${SOFTWARE_LIBRARY_NAME}!" && shell_script_library_uninstall ;;
    esac

    cp "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY" "$PATH_LIBRARY_STORAGE_FILE_RESULT" && \
        echo -e "$SOFTWARE_LIBRARY_NAME installation process has been completed!" || \
        echo -e "$SOFTWARE_LIBRARY_NAME installation process has been failed!"
}

#@annotation_must_be_tested
shell_script_library_modules_action_clear_main() {
    local MODULE_ACTION_PLACE="$1"
    local FILENAME_WITH_FULL_PATH

    case "$MODULE_ACTION_PLACE" in
    "library")
        {
            for i in "$PATH_LIBRARY_MODULES_FILES_COMPILING"/*.sh; do
                FILENAME_WITH_FULL_PATH="${i}"
                shell_script_library_modules_action_clear_library "$FILENAME_WITH_FULL_PATH"
            done
        } && \
            echo -e "Clearing library modules files process has been completed!" || \
                echo -e "Clearing library modules files process has been failed!"
        ;;
    "tester")
        {
            for i in "$PATH_LIBRARY_MODULES_FILES_COMPILING"/*.sh; do
                FILENAME_WITH_FULL_PATH="${i}"
                shell_script_library_modules_action_clear_tester "$FILENAME_WITH_FULL_PATH"
            done
        } && \
            echo -e "Clearing tester modules files process has been completed!" || \
                echo -e "Clearing tester modules files process has been failed!"
        ;;
    esac
}

shell_script_library_modules_action_merge_main() {
    local MODULE_ACTION_PLACE="$1"
    local FILENAME_WITH_FULL_PATH

    case "$MODULE_ACTION_PLACE" in
    "library")
        {
            #Clean up the older file version
            utils_clear_file >"$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY"

            #Compile all modules into one single file
            cat "$PATH_LIBRARY_MODULES_FILES_COMPILING"/header.txt >"$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY"

            for i in "$PATH_LIBRARY_MODULES_FILES_COMPILING"/*.sh; do
                FILENAME_WITH_FULL_PATH="${i}"
                shell_script_library_modules_action_merge_library "$FILENAME_WITH_FULL_PATH"
            done
        } && \
            echo -e "Merging library modules files process has been completed!" || 
                echo -e "Merging library modules files process has been failed!"
        ;;
    "tester")
        {
            #Clean up the older file version
            utils_clear_file >"$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"

            #Compile all modules into one single file
            cat "$PATH_LIBRARY_MODULES_FILES_COMPILING"/header_.txt >"$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"

            for i in "$PATH_LIBRARY_MODULES_FILES_COMPILING"/*.sh; do
                FILENAME_WITH_FULL_PATH="${i}"
                shell_script_library_modules_action_merge_tester "$FILENAME_WITH_FULL_PATH"
            done
        } && \
            echo -e "Merging tester modules files process has been completed!" || \
                echo -e "Merging tester modules files process has been failed!"
        ;;
    esac
}

shell_script_library_run_main() {
    local MODULE_ACTION_PLACE="$1"

    case "$MODULE_ACTION_PLACE" in
    "library") shell_script_library_run_library ;;
    "tester") shell_script_library_run_tester ;;
    esac
}

shell_script_library_uninstall() {
    case $(utils_check_if_file_exists "$PATH_LIBRARY_STORAGE_FILE_RESULT") in
    "false") echo -e "${SOFTWARE_LIBRARY_NAME} uninstalling process has been not necessary. File has not been found!" ;;
    "true")
        rm "$PATH_LIBRARY_STORAGE_FILE_RESULT" && \
            echo -e "${SOFTWARE_LIBRARY_NAME} uninstalling process has been completed!" || \
                echo -e "${SOFTWARE_LIBRARY_NAME} uninstalling process has been failed!"
        ;;
    esac
}

shell_script_library_version() {
    echo -e "${SOFTWARE_MERGER_NAME} version ${SOFTWARE_MERGER_VERSION}"
}

##############################
#Calling the functions
##############################

#clear

#Display help message if any argument has been informed
if [[ "$#" -eq 0 ]]; then
    echo -e "$MESSAGE_HELP"
    exit 0
fi

#Calling the functions according to the informed arguments
while [ "$#" -ne 0 ]; do
    #Debug mode for checking the current '$1' variable value
    #echo -e "Current parameter[S1] has '$1' value"

    #Check the set parameters
    case "$1" in
    "-h" | "--help" | "-?")
        echo -e "$MESSAGE_HELP"
        break
        ;;
    "-e" | "--edit")
        "$EDITOR" "$0"
        break
        ;;
    #"-c-library" | "--clear-library") shell_script_library_modules_action_clear_main "library" ;;
    #"-c-tester" | "--clear-tester") shell_script_library_modules_action_clear_main "tester" ;;
    "-d" | "--download") shell_script_library_repository_clone ;;
    "-i" | "--install") shell_script_library_install ;;
    
    "-mh-library" | "--minify-hard-library") shell_script_library_minify_soft "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY" ;;
    #"-mh-tester" | "--minify-hard-library") shell_script_library_minify_soft "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER" ;;
    
    "-ms-library" | "--minify-library") shell_script_library_minify_soft "$PATH_LIBRARY_MODULES_FILES_RESULT_LIBRARY" ;;
    #"-ms-tester" | "--minify-library") shell_script_library_minify_soft "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER" ;;

    "-m-library" | "--merge-library") shell_script_library_modules_action_merge_main "library" ;;
    "-m-tester" | "--merge-tester") shell_script_library_modules_action_merge_main "tester" ;;
    "-r-library" | "--run-library") shell_script_library_run_main "library" ;;
    "-r-tester" | "--run-tester") shell_script_library_run_main "tester" ;;
    "-u" | "--uninstall") shell_script_library_uninstall ;;
    "-v" | "--version") shell_script_library_version ;;
    *)
        echo -e "Invalid option for '$1 parameter'!\n$MESSAGE_HELP"
        break
        ;;
    esac

    shift
done