#!/usr/bin/env bash

##############################
#Declaring variables
##############################

EDITOR="vim"

#Use path /run/host/ #For Flatpak applications
PATH_SCRIPT="$(dirname "$(readlink -f "$0")")"
PATH_LIBRARY_MODULES_FILES_COMPILING="$PATH_SCRIPT/modules"
PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL="$PATH_SCRIPT/shell-script-library"
PATH_LIBRARY_MODULES_FILES_RESULT_TESTER="$PATH_SCRIPT/shell-script-library-tester"
PATH_LIBRARY_STORAGE_FILE_RESULT=""

#shellcheck source=/dev/null
. "$PATH_SCRIPT/settings.conf" || exit

case "$UID" in
0) PATH_LIBRARY_STORAGE_FILE_RESULT="$PATH_LIBRARY_STORAGE_FILE_SYSTEM" ;;
*) PATH_LIBRARY_STORAGE_FILE_RESULT="$PATH_LIBRARY_STORAGE_FILE_USER" ;;
esac

MESSAGE_HELP="
\t\t\t\t\t\t\t$SOFTWARE_MERGER_NAME
\t\t\t\t\t\t\t---------------------------
[Credits]
Author: $SOFTWARE_MERGER_AUTHOR
E-mail: $SOFTWARE_MERGER_EMAIL
License: $SOFTWARE_MERGER_LICENSE
Version: $SOFTWARE_MERGER_VERSION

[Description]
This is a dedicated merger tool for $SOFTWARE_LIBRARY_NAME project which can be used to pack all modules into one single file. This is the way the final $SOFTWARE_LIBRARY_NAME archieve is generated by default.

Furthermore this tool also generate the unit test file for debugging the $SOFTWARE_LIBRARY_NAME.

[Extra functions]
1. This tool can be used as a default installer of the $SOFTWARE_LIBRARY_NAME. By running this script file with root permition the generated $SOFTWARE_LIBRARY_NAME is going to be installed on $PATH_LIBRARY_STORAGE_FILE_SYSTEM path. Without root previledges it is going to be installed on $PATH_LIBRARY_STORAGE_FILE_USER path. In case the $SOFTWARE_LIBRARY_NAME is already installed, this tool makes the $SOFTWARE_LIBRARY_NAME update.

1. This tool can be used to uninstall the $SOFTWARE_LIBRARY_NAME.

1. This tool can be used to clear all the files modules content but still presenving the generated $SOFTWARE_LIBRARY_NAME file. The reason of this function has created was to solve the problem when this project must hardly rename functions from many modules at once. One real example was about when display_message_empty api was renamed to display_message_value_status_empty_simple. Many of bugs would be avoid if this tool had been existed. By the way it can be very useful in future source code refactory (this is in experimental mode).

[Merger rules]
Modules files names whose ends with _.sh character is considered as part of the unit test.
Modules files names whose starts with _ character is ignored by the merger.
Modules files names whose does not start with _ character and does not end w _.sh character is considered as part of the library.
Only .sh files are processed. Except for header.txt and header_.txt files.

[Parameters]
-h\t\t--help\t-?\t\tDisplay this message help
-e\t\t--edit\t\t\tEdit this script file with $EDITOR software.
-c-library\t--clear-library\t\tClear all the library modules files content from ${PATH_LIBRARY_MODULES_FILES_COMPILING}/.
-c-tester\t--clear-tester\t\tClear all the tester modules files content from ${PATH_LIBRARY_MODULES_FILES_COMPILING}/.
-i\t\t--install\t\tInstall the $SOFTWARE_LIBRARY_NAME by moving the compiled file to ${PATH_LIBRARY_STORAGE_FILE_RESULT}.
-m-library\t--merge-library\t\tCompile all the library modules files content into ${PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL}.
-m-library\t--merge-library\t\tCompile all the tester modules files content into ${PATH_LIBRARY_MODULES_FILES_RESULT_TESTER}.
-r-library\t--run-library\t\tRun/import $PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL file.
-r-tester\t--run-tester\t\tRun $PATH_LIBRARY_MODULES_FILES_RESULT_TESTER file.
-u\t\t--uninstall\t\tUninstall the $SOFTWARE_LIBRARY_NAME by removing the compiled file from ${PATH_LIBRARY_STORAGE_FILE_RESULT}.
-v\t\t--version\t\tDisplay $SOFTWARE_MERGER_NAME version
"

##############################
#Functions - tools
##############################

utils_check_if_file_exists() {
    local VALUE_PATH_FILE="$1"

    if [[ -f $VALUE_PATH_FILE ]]; then
        echo "true"
    else
        echo "false"
    fi
}

utils_check_if_folder_exists() {
    local VALUE_PATH_FOLDER="$1"

    if [[ -d "$VALUE_PATH_FOLDER" ]]; then
        echo "true"
    else
        echo "false"
    fi
}

utils_clear_file() {
    local PATH_FILE="$1"

    echo -e "Clearing terminal history"

    case $(utils_check_if_file_exists "$PATH_FILE") in
    "false")
        echo -e "File $PATH_FILE does not exists"
        ;;
    "true")
        cat /dev/null >"$PATH_FILE"
        ;;
    esac
}

##############################
#Functions - normal
##############################

shell_script_library_modules_action_clear_original() {
    local FILENAME_WITH_FULL_PATH="$1"
    local FILENAME_WITHOUT_FULL_PATH="${FILENAME_WITH_FULL_PATH##*/}"

    #Check if file name does not start with _ character
    if [[ ! "$FILENAME_WITHOUT_FULL_PATH" =~ ^_ ]]; then
        echo "Clearing the $FILENAME_WITH_FULL_PATH module file content..."
        utils_clear_file "$FILENAME_WITH_FULL_PATH"
    fi
}

shell_script_library_modules_action_clear_tester() {
    local FILENAME_WITH_FULL_PATH="$1"
    local FILENAME_WITHOUT_FULL_PATH="${FILENAME_WITH_FULL_PATH##*/}"

    #Check if file name starts with _ character
    if [[ "$FILENAME_WITHOUT_FULL_PATH" =~ ^_ ]]; then
        echo "Clearing the $FILENAME_WITH_FULL_PATH module file content..."
        utils_clear_file "$FILENAME_WITH_FULL_PATH"
    fi
}

shell_script_library_modules_action_merge_original() {
    local FILENAME_WITH_FULL_PATH="$1"
    local FILENAME_WITHOUT_FULL_PATH="${FILENAME_WITH_FULL_PATH##*/}"

    local REGEX_EXPRESSION_A='^_.*.sh'
    local REGEX_EXPRESSION_B='.*_.sh'

    #Check if file name does not start with _ character and does not ends with _.sh value
    if [[ ! "$FILENAME_WITHOUT_FULL_PATH" =~ $REGEX_EXPRESSION_A ]] && [[ ! "$FILENAME_WITHOUT_FULL_PATH" =~ $REGEX_EXPRESSION_B ]]; then
        #echo "Compiling the $FILENAME_WITHOUT_FULL_PATH module file content into $PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL..."
        echo -e "\n" >>"$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL"
        cat "$FILENAME_WITH_FULL_PATH" >>"$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL"
    fi
}

shell_script_library_modules_action_merge_tester() {
    local FILENAME_WITH_FULL_PATH="$1"
    local FILENAME_WITHOUT_FULL_PATH="${FILENAME_WITH_FULL_PATH##*/}"

    local REGEX_EXPRESSION='.*_.sh'

    #Check if file name starts with _ character
    if [[ "$FILENAME_WITHOUT_FULL_PATH" =~ $REGEX_EXPRESSION ]]; then
        #echo "Compiling the $FILENAME_WITHOUT_FULL_PATH module file content into $PATH_LIBRARY_MODULES_FILES_RESULT_TESTER..."

        echo -e "\n" >>"$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"
        cat "$FILENAME_WITH_FULL_PATH" >>"$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"
    fi
}

shell_script_library_run_original() {
    case $(utils_check_if_file_exists "$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL") in
    "false") echo "Error! $PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL file does not exists" ;;
    "true")
        chmod +x "$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL"
        "$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL"
        ;;
    esac
}

shell_script_library_run_tester() {
    case $(utils_check_if_file_exists "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER") in
    "false") echo "Error! $PATH_LIBRARY_MODULES_FILES_RESULT_TESTER file does not exists" ;;
    "true")
        chmod +x "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"
        "$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"
        ;;
    esac
}

##############################
#Functions - calling
##############################

shell_script_library_install() {
    case $(utils_check_if_file_exists "$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL") in
    "false") : ;;
    "true") echo -e "Reinstalling the ${SOFTWARE_LIBRARY_NAME}!" && shell_script_library_uninstall ;;
    esac

    cp "$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL" "$PATH_LIBRARY_STORAGE_FILE_RESULT" && echo -e "${SOFTWARE_LIBRARY_NAME} installation process has been completed!" || echo -e "${SOFTWARE_LIBRARY_NAME}installation process has been failed!"
}

shell_script_library_modules_action_clear_main() {
    local MODULE_ACTION_PLACE="$1"
    local FILENAME_WITH_FULL_PATH

    case "$MODULE_ACTION_PLACE" in
    "library")
        {
            for i in "$PATH_LIBRARY_MODULES_FILES_COMPILING"/*.sh; do
                FILENAME_WITH_FULL_PATH="${i}"
                shell_script_library_modules_action_clear_original "$FILENAME_WITH_FULL_PATH"
            done
        } && echo -e "Clearing library modules files process has been completed!" || echo -e "Clearing library modules files process has been failed!"
        ;;
    "tester")
        {
            for i in "$PATH_LIBRARY_MODULES_FILES_COMPILING"/*.sh; do
                FILENAME_WITH_FULL_PATH="${i}"
                shell_script_library_modules_action_clear_tester "$FILENAME_WITH_FULL_PATH"
            done
        } && echo -e "Clearing tester modules files process has been completed!" || echo -e "Clearing tester modules files process has been failed!"
        ;;
    esac
}

shell_script_library_modules_action_merge_main() {
    local MODULE_ACTION_PLACE="$1"
    local FILENAME_WITH_FULL_PATH

    case "$MODULE_ACTION_PLACE" in
    "library")
        {
            #Clean up the older file version
            utils_clear_file >"$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL"

            #Compile all modules into one single file
            cat "$PATH_LIBRARY_MODULES_FILES_COMPILING"/header.txt >"$PATH_LIBRARY_MODULES_FILES_RESULT_ORIGINAL"

            for i in "$PATH_LIBRARY_MODULES_FILES_COMPILING"/*.sh; do
                FILENAME_WITH_FULL_PATH="${i}"
                shell_script_library_modules_action_merge_original "$FILENAME_WITH_FULL_PATH"
            done
        } && echo -e "Merging library modules files process has been completed!" || echo -e "Merging library modules files process has been failed!"
        ;;
    "tester")
        {
            #Clean up the older file version
            utils_clear_file >"$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"

            #Compile all modules into one single file
            cat "$PATH_LIBRARY_MODULES_FILES_COMPILING"/header_.txt >"$PATH_LIBRARY_MODULES_FILES_RESULT_TESTER"

            for i in "$PATH_LIBRARY_MODULES_FILES_COMPILING"/*.sh; do
                FILENAME_WITH_FULL_PATH="${i}"
                shell_script_library_modules_action_merge_tester "$FILENAME_WITH_FULL_PATH"
            done
        } && echo -e "Merging tester modules files process has been completed!" || echo -e "Merging tester modules files process has been failed!"
        ;;
    esac
}

shell_script_library_run_main() {
    local MODULE_ACTION_PLACE="$1"

    case "$MODULE_ACTION_PLACE" in
    "library") shell_script_library_run_original ;;
    "tester") shell_script_library_run_tester ;;
    esac
}

shell_script_library_uninstall() {
    case $(utils_check_if_file_exists "$PATH_LIBRARY_STORAGE_FILE_RESULT") in
    "false") : && echo -e "${SOFTWARE_LIBRARY_NAME} uninstalling process has been not necessary. File not found!" ;;
    "true") rm "$PATH_LIBRARY_STORAGE_FILE_RESULT" && echo -e "${SOFTWARE_LIBRARY_NAME} uninstalling process has been completed!" || echo -e "${SOFTWARE_LIBRARY_NAME} uninstalling process has been failed!" ;;
    esac
}

shell_script_library_version() {
    echo -e "${SOFTWARE_MERGER_NAME} version ${SOFTWARE_MERGER_VERSION}"
}

##############################
#Calling the functions
##############################

declare -i AUX=0

while [ -n "$1" ]; do
    #echo -e "The parameter[$AUX] has '$1' value"

    #Check the set parameters
    case $1 in
    "-h" | "--help" | "-?")
        echo -e "$MESSAGE_HELP"
        break
        ;;
    "-e" | "--edit")
        "$EDITOR" "$0"
        break
        ;;
        #"-c-library" | "--clear-library") shell_script_library_modules_action_clear_main "library" ;;
        #"-c-tester" | "--clear-tester") shell_script_library_modules_action_clear_main "tester" ;;
    "-i" | "--install") shell_script_library_install ;;
    "-m-library" | "--merge-library") shell_script_library_modules_action_merge_main "library" ;;
    "-m-tester" | "--merge-tester") shell_script_library_modules_action_merge_main "tester" ;;
    "-r-library" | "--run-library") shell_script_library_run_main "library" ;;
    "-r-tester" | "--run-tester") shell_script_library_run_main "tester" ;;
    "-u" | "--uninstall") shell_script_library_uninstall ;;
    "-v" | "--version") shell_script_library_version ;;
    *)
        if [[ $AUX -eq 0 ]]; then
            echo -e "Invalid option for $0!\n$MESSAGE_HELP"
        else
            echo -e "Invalid option for '$1' parameter."
        fi

        break
        ;;
    esac

    #Increment $i value to go to the next available parameter value
    AUX=$((AUX + 1))
    shift
done
